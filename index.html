<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>My Web Map</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

<!-- ✅ Icon library -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>

<style>
  html, body { margin: 0; padding: 0; height: 100%; }
  #map { width: 100%; height: 100%; }

  #info {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: white;
    padding: 8px 10px;
    border: 1px solid #aaa;
    font-family: Arial, sans-serif;
    font-size: 12px;
    z-index: 1000;
    max-width: 380px;
    line-height: 1.3;
  }

  /* better hit testing for lines */
  .leaflet-interactive { pointer-events: stroke; }

  /* ✅ selection toggle icon styling */
  .sel-btn {
    width: 32px;
    height: 32px;
    display: grid;
    place-items: center;
    background: white;
    cursor: pointer;
    user-select: none;
  }
  .sel-btn i { font-size: 16px; }
  .sel-on  { color: #18a558; }  /* green */
  .sel-off { color: #d64545; }  /* red */
</style>
</head>

<body>
<div id="map"></div>

<div id="info">
  <b>Info</b><br>Turn on a layer, then click a feature.
</div>

<script>
// ================================
// MAP
// ================================
const map = L.map('map', {
  center: [50, -100],
  zoom: 4,
  minZoom: 2,
  worldCopyJump: false,
  maxBoundsViscosity: 1.0,
  attributionControl: false,
  doubleClickZoom: false
});

L.control.attribution({ prefix: false }).addTo(map);

const infoDiv = document.getElementById('info');

// ---- World extent (optional)
const bounds = L.latLngBounds(L.latLng(-90,-180), L.latLng(90,180));
map.setMaxBounds(bounds);

// ================================
// BASEMAPS
// ================================
const basemapOSM = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 25,
  noWrap: true,
  bounds: bounds,
  attribution: '© OpenStreetMap contributors'
});

const basemapTopo = L.tileLayer(
  'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',
  { maxZoom: 25, attribution: 'Tiles © Esri' }
);

const basemapSatellite = L.tileLayer(
  'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
  { maxZoom: 25, attribution: 'Tiles © Esri' }
);

const basemapOpenTopo = L.tileLayer(
  'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
  { maxZoom: 17, attribution: '© OpenTopoMap (CC-BY-SA)' }
);

const basemapLight = L.tileLayer(
  'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
  { maxZoom: 25, attribution: '© CartoDB' }
);

const basemapDark = L.tileLayer(
  'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
  { maxZoom: 25, attribution: '© CartoDB' }
);

const basemapHillshade = L.tileLayer(
  'https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}',
  { maxZoom: 20, attribution: '© Esri' }
);

// default
basemapOSM.addTo(map);

const baseMaps = {
  "OpenStreetMap": basemapOSM,
  "ESRI Topo": basemapTopo,
  "ESRI Satellite": basemapSatellite,
  "OpenTopoMap": basemapOpenTopo,
  "Light Mode": basemapLight,
  "Dark Mode": basemapDark,
  "ESRI Hillshade": basemapHillshade
};

// overlays + layer control
const overlayLayers = {};
const layerControl = L.control.layers(baseMaps, overlayLayers, { collapsed: false }).addTo(map);

// expose globals (loader uses these)
window.map = map;
window.overlayLayers = overlayLayers;
window.layerControl = layerControl;

// ================================
// PANE FOR GEOJSON
// ================================
map.createPane('geojsonPane');
map.getPane('geojsonPane').style.zIndex = 650;
map.getPane('geojsonPane').style.pointerEvents = 'auto';
window.geojsonPane = 'geojsonPane';


// ================================
// GLOBAL SELECTION (works for ANY layer)
// ================================
let selectionEnabled = true;
let selected = null;
window.__selectedLayer = null;

function clearSelection() {
  if (selected && selected.setStyle && selected._origStyle) {
    try { selected.setStyle(selected._origStyle); } catch (e) {}
  }
  selected = null;
  window.__selectedLayer = null;

  if (typeof window.__updateSelectedMeasureUI === "function") {
    window.__updateSelectedMeasureUI();
  }

  infoDiv.innerHTML = `<b>Info</b><br>Turn on a layer, then click a feature.`;
}

function fmtCoord(x) {
  return Number.isFinite(x) ? x.toFixed(6) : "";
}

function makeSelectable(layer, name = "Feature") {
  if (!layer) return;

  layer._layerName = name;

  // ensure interactive
  if (layer.options) layer.options.interactive = true;

  layer.on("click", (e) => {
    // ✅ selection OFF => do nothing
    if (!selectionEnabled) {
      L.DomEvent.stopPropagation(e);
      return;
    }

    // click same feature again => deselect
    if (selected === layer) {
      clearSelection();
      L.DomEvent.stopPropagation(e);
      return;
    }

    // restore previous (only for vector paths)
    if (selected && selected.setStyle && selected._origStyle) {
      try { selected.setStyle(selected._origStyle); } catch (err) {}
    }

    // store original style once (only for vector paths)
    if (layer.setStyle && !layer._origStyle) {
      layer._origStyle = {
        color: layer.options?.color || "#3388ff",
        weight: layer.options?.weight || 3,
        opacity: layer.options?.opacity ?? 1,
        fillColor: layer.options?.fillColor,
        fillOpacity: layer.options?.fillOpacity
      };
    }

    // highlight (only for vector paths)
    if (layer.setStyle) layer.setStyle({ color: "yellow", weight: 6, opacity: 1 });
    if (layer.bringToFront) layer.bringToFront();

    selected = layer;
    window.__selectedLayer = layer;

    if (typeof window.__updateSelectedMeasureUI === "function") {
      window.__updateSelectedMeasureUI();
    }

    const layerName = layer._layerName || "Unnamed";

    // ✅ If this is a marker/point, show lat/lng
    let extra = "";
    if (typeof layer.getLatLng === "function") {
      const ll = layer.getLatLng();
      extra = `<br><b>Lat:</b> ${fmtCoord(ll.lat)}<br><b>Lng:</b> ${fmtCoord(ll.lng)}`;
    }

    const html = `<b>Layer:</b> ${layerName}${extra}`;

    if (layer.bindPopup) layer.bindPopup(html).openPopup();
    infoDiv.innerHTML = `<b>Selected</b><br>${html}`;

    L.DomEvent.stopPropagation(e);
  });
}

// This is what your loader calls for GeoJSON features
window.attachSelectableFeature = function(feature, layer) {
  makeSelectable(layer, layer._layerName || "Layer");
};


// ================================
// ✅ SELECTION ICON CONTROL (single button)
// ================================
const SelectionIconControl = L.Control.extend({
  onAdd: function () {
    const container = L.DomUtil.create('div', 'leaflet-bar');
    const btn = L.DomUtil.create('a', 'sel-btn', container);
    btn.href = "#";
    btn.title = "Toggle selection (ON/OFF)";

    btn.innerHTML = `<i class="fa-solid fa-mouse-pointer sel-on"></i>`;

    function refresh() {
      const icon = btn.querySelector("i");
      icon.classList.remove("sel-on", "sel-off");
      icon.classList.add(selectionEnabled ? "sel-on" : "sel-off");
      btn.title = selectionEnabled ? "Selection: ON (click to turn OFF)" : "Selection: OFF (click to turn ON)";
    }

    btn.addEventListener('click', (e) => {
      e.preventDefault();
      selectionEnabled = !selectionEnabled;
      if (!selectionEnabled) clearSelection();
      refresh();
    });

    L.DomEvent.disableClickPropagation(container);
    L.DomEvent.disableScrollPropagation(container);

    refresh();
    return container;
  }
});
map.addControl(new SelectionIconControl({ position: 'topright' }));


// ================================
// DRAW (leaflet-draw)
// ================================
const drawnItems = new L.FeatureGroup().addTo(map);

const drawControl = new L.Control.Draw({
  position: "topright",
  edit: { featureGroup: drawnItems },
  draw: {
    polygon: true,
    polyline: true,
    rectangle: true,
    circle: false,
    marker: true,
    circlemarker: false
  }
});
map.addControl(drawControl);

map.on(L.Draw.Event.CREATED, function (e) {
  const layer = e.layer;
  drawnItems.addLayer(layer);
  makeSelectable(layer, "Draw");
});


// ================================
// BUFFER TOOL
// ================================
let bufferLayer = null;

const BufferControl = L.Control.extend({
  onAdd: function () {
    const div = L.DomUtil.create('div', 'leaflet-bar');
    div.style.background = 'white';
    div.style.padding = '8px';
    div.style.fontFamily = 'Arial, sans-serif';
    div.style.fontSize = '12px';
    div.style.lineHeight = '1.2';
    div.style.minWidth = '160px';

    div.innerHTML = `
      <div style="font-weight:bold; margin-bottom:6px;">Buffer</div>
      <div style="display:flex; gap:6px; align-items:center;">
        <input id="bufDist" type="number" value="10" min="0" step="1"
               style="width:70px; padding:3px;" />
        <select id="bufUnit" style="padding:3px;">
          <option value="meters" selected>m</option>
          <option value="kilometers">km</option>
          <option value="feet">ft</option>
          <option value="miles">mi</option>
        </select>
        <button id="bufBtn" style="padding:3px 6px; cursor:pointer;">Create</button>
      </div>
      <div style="margin-top:6px;">
        <button id="bufClear" style="padding:3px 6px; cursor:pointer;">Clear</button>
      </div>
    `;

    L.DomEvent.disableClickPropagation(div);
    L.DomEvent.disableScrollPropagation(div);

    div.querySelector('#bufBtn').addEventListener('click', () => {
      if (!window.__selectedLayer) {
        alert("Select a feature first.");
        return;
      }

      const dist = Number(div.querySelector('#bufDist').value);
      const unit = div.querySelector('#bufUnit').value;

      if (!Number.isFinite(dist) || dist <= 0) {
        alert("Enter a buffer distance > 0.");
        return;
      }

      const gj = window.__selectedLayer.toGeoJSON();
      const buffered = turf.buffer(gj, dist, { units: unit });

      if (bufferLayer) map.removeLayer(bufferLayer);

      bufferLayer = L.geoJSON(buffered, {
        pane: window.geojsonPane || 'overlayPane',
        interactive: true,
        style: { weight: 2, opacity: 1, fillOpacity: 0.15 }
      }).addTo(map);

      bufferLayer.eachLayer(sub => makeSelectable(sub, "Buffer"));

      try { map.fitBounds(bufferLayer.getBounds(), { padding: [20, 20] }); } catch (e) {}
    });

    div.querySelector('#bufClear').addEventListener('click', () => {
      if (bufferLayer) {
        map.removeLayer(bufferLayer);
        bufferLayer = null;
      }
    });

    return div;
  }
});
map.addControl(new BufferControl({ position: 'topright' }));


// ================================
// MANUAL MEASURE TOOL (click points)
// ================================
const measureGroup = L.featureGroup().addTo(map);

let measuring = null; // "length" | "area" | null
let measurePts = [];
let tempLine = null;
let tempPoly = null;
let tempTooltip = null;

function formatLength(m) {
  if (m >= 1000) return (m / 1000).toFixed(3) + " km";
  return m.toFixed(2) + " m";
}
function formatArea(m2) {
  if (m2 >= 1e5) return (m2 / 1e6).toFixed(3) + " km²";
  return m2.toFixed(2) + " m²";
}

function clearMeasure() {
  measureGroup.clearLayers();
  measurePts = [];
  measuring = null;
  tempLine = null;
  tempPoly = null;
  if (tempTooltip) { map.removeLayer(tempTooltip); tempTooltip = null; }
  map.getContainer().style.cursor = '';
}

function startMeasure(mode) {
  clearMeasure();
  measuring = mode;
  map.getContainer().style.cursor = 'crosshair';
  infoDiv.innerHTML = `<b>Measure</b><br>${mode === "length" ? "Length" : "Area"} mode: click points, double-click to finish.`;
}

map.on('dblclick', (e) => {
  if (!measuring) return;
  L.DomEvent.stop(e);
});

function updateMeasureGraphics(cursorLatLng) {
  if (!measuring || measurePts.length === 0) return;

  const latlngs = [...measurePts, cursorLatLng];

  if (tempLine) measureGroup.removeLayer(tempLine);
  tempLine = L.polyline(latlngs, { weight: 2, opacity: 1 }).addTo(measureGroup);

  if (measuring === "area") {
    if (tempPoly) measureGroup.removeLayer(tempPoly);
    tempPoly = L.polygon(latlngs, { weight: 2, opacity: 1, fillOpacity: 0.15 }).addTo(measureGroup);
  }

  let text = "";
  const coords = latlngs.map(ll => [ll.lng, ll.lat]);

  if (measuring === "length") {
    const line = turf.lineString(coords);
    const km = turf.length(line, { units: "kilometers" });
    text = "Length: " + formatLength(km * 1000);
  } else if (measuring === "area" && latlngs.length >= 3) {
    const poly = turf.polygon([[...coords, coords[0]]]);
    const a = turf.area(poly);
    text = "Area: " + formatArea(a);
  } else {
    text = (measuring === "area") ? "Click 3+ points…" : "Click more points…";
  }

  if (tempTooltip) map.removeLayer(tempTooltip);
  tempTooltip = L.tooltip({ permanent: false, direction: 'top' })
    .setLatLng(cursorLatLng)
    .setContent(text)
    .addTo(map);
}

map.on('click', (e) => {
  if (!measuring) return;
  measurePts.push(e.latlng);
  L.circleMarker(e.latlng, { radius: 4, opacity: 1, fillOpacity: 1 }).addTo(measureGroup);
});

map.on('mousemove', (e) => {
  if (!measuring) return;
  updateMeasureGraphics(e.latlng);
});

map.on('dblclick', (e) => {
  if (!measuring) return;

  if (measuring === "length" && measurePts.length >= 2) {
    const coords = measurePts.map(ll => [ll.lng, ll.lat]);
    const line = turf.lineString(coords);
    const km = turf.length(line, { units: "kilometers" });
    infoDiv.innerHTML = `<b>Measure result</b><br>Length: ${formatLength(km * 1000)}`;
  }

  if (measuring === "area" && measurePts.length >= 3) {
    const coords = measurePts.map(ll => [ll.lng, ll.lat]);
    const poly = turf.polygon([[...coords, coords[0]]]);
    const a = turf.area(poly);
    infoDiv.innerHTML = `<b>Measure result</b><br>Area: ${formatArea(a)}`;
  }

  measuring = null;
  map.getContainer().style.cursor = '';
  if (tempTooltip) { map.removeLayer(tempTooltip); tempTooltip = null; }
});

const MeasureControl = L.Control.extend({
  onAdd: function () {
    const div = L.DomUtil.create('div', 'leaflet-bar');
    div.style.background = 'white';
    div.style.padding = '8px';
    div.style.fontFamily = 'Arial, sans-serif';
    div.style.fontSize = '12px';
    div.style.minWidth = '160px';

    div.innerHTML = `
      <div style="font-weight:bold; margin-bottom:6px;">Measure</div>
      <div style="display:flex; gap:6px; flex-wrap:wrap;">
        <button id="mLen" style="padding:3px 6px; cursor:pointer;">Length</button>
        <button id="mArea" style="padding:3px 6px; cursor:pointer;">Area</button>
        <button id="mClear" style="padding:3px 6px; cursor:pointer;">Clear</button>
      </div>
    `;

    L.DomEvent.disableClickPropagation(div);
    L.DomEvent.disableScrollPropagation(div);

    div.querySelector('#mLen').onclick = () => startMeasure("length");
    div.querySelector('#mArea').onclick = () => startMeasure("area");
    div.querySelector('#mClear').onclick = () => clearMeasure();

    return div;
  }
});
map.addControl(new MeasureControl({ position: 'topright' }));


// ================================
// TOGGLEABLE "MEASURE SELECTED FEATURE"
// ================================
let selectedMeasureEnabled = false; // default OFF

function measureSelectedFeature(layer) {
  if (!layer || !layer.toGeoJSON) return { ok: false, msg: "No selection." };

  const gj = layer.toGeoJSON();
  const type = gj?.geometry?.type;
  if (!type) return { ok: false, msg: "No geometry." };

  if (type === "LineString" || type === "MultiLineString") {
    const km = turf.length(gj, { units: "kilometers" });
    return { ok: true, kind: "Length", value: formatLength(km * 1000) };
  }

  if (type === "Polygon" || type === "MultiPolygon") {
    const a = turf.area(gj);
    return { ok: true, kind: "Area", value: formatArea(a) };
  }

  if (type === "Point" || type === "MultiPoint") {
    // (optional) you can show coords here too, but your popup already shows them
    return { ok: true, kind: "Info", value: "Point selected (see popup for lat/lng)." };
  }

  return { ok: true, kind: "Info", value: `Selected: ${type}` };
}

const SelectedMeasureControl = L.Control.extend({
  onAdd: function () {
    const div = L.DomUtil.create('div', 'leaflet-bar');
    div.style.background = 'white';
    div.style.padding = '8px';
    div.style.fontFamily = 'Arial, sans-serif';
    div.style.fontSize = '12px';
    div.style.minWidth = '160px';

    div.innerHTML = `
      <div style="font-weight:bold; margin-bottom:6px;">Selected Measure</div>
      <div style="display:flex; gap:6px; flex-wrap:wrap;">
        <button id="selToggle" style="padding:3px 6px; cursor:pointer;">Enable</button>
        <button id="selMeasureBtn" style="padding:3px 6px; cursor:pointer;" disabled>Measure</button>
        <button id="selClear" style="padding:3px 6px; cursor:pointer;" disabled>Clear</button>
      </div>
      <div id="selMeasureText" style="margin-top:6px;">Disabled</div>
    `;

    L.DomEvent.disableClickPropagation(div);
    L.DomEvent.disableScrollPropagation(div);

    const btnToggle = div.querySelector('#selToggle');
    const btnMeasure = div.querySelector('#selMeasureBtn');
    const btnClear = div.querySelector('#selClear');
    const out = div.querySelector('#selMeasureText');

    function render() {
      if (!selectedMeasureEnabled) {
        btnToggle.textContent = "Enable";
        btnMeasure.disabled = true;
        btnClear.disabled = true;
        out.textContent = "Disabled";
        return;
      }

      btnToggle.textContent = "Disable";
      btnMeasure.disabled = false;
      btnClear.disabled = false;

      if (!window.__selectedLayer) {
        out.textContent = "Select a feature";
        return;
      }

      const res = measureSelectedFeature(window.__selectedLayer);
      if (!res.ok) out.textContent = res.msg;
      else if (res.kind === "Info") out.textContent = res.value;
      else out.innerHTML = `<b>${res.kind}:</b> ${res.value}`;
    }

    btnToggle.onclick = () => { selectedMeasureEnabled = !selectedMeasureEnabled; render(); };
    btnMeasure.onclick = () => { if (!selectedMeasureEnabled) return; render(); };
    btnClear.onclick = () => { out.textContent = selectedMeasureEnabled ? "Select a feature" : "Disabled"; };

    window.__updateSelectedMeasureUI = () => { if (!selectedMeasureEnabled) return; render(); };

    render();
    return div;
  }
});
map.addControl(new SelectedMeasureControl({ position: 'topright' }));

</script>

<!-- Load all GeoJSON layers -->
<script src="Layers_updating_By_Layers_json.js"></script>

</body>
</html>
