<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>My Web Map </title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

<style>
  html, body { margin: 0; padding: 0; height: 100%; }
  #map { width: 100%; height: 100%; }

  #info {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: white;
    padding: 8px 10px;
    border: 1px solid #aaa;
    font-family: Arial, sans-serif;
    font-size: 12px;
    z-index: 1000;
    max-width: 380px;
    line-height: 1.3;
  }

  /* better hit testing for lines */
  .leaflet-interactive { pointer-events: stroke; }
</style>
</head>

<body>
<div id="map"></div>

<div id="info"
     style="position:absolute; bottom:10px; left:10px; z-index:1000; background:white; padding:8px 10px; border:1px solid #aaa; font-family:Arial; font-size:12px;">
  <b>Info</b><br>Turn on a layer, then click a feature.
</div>

<script>
// ================================
// MAP
// ================================
const map = L.map('map', {
  center: [50, -100],
  zoom: 4,
  minZoom: 2,
  worldCopyJump: false,
  maxBoundsViscosity: 1.0,
  attributionControl: false,
  doubleClickZoom: false
});

L.control.attribution({ prefix: false }).addTo(map);

// ---- World extent (optional but fine)
const bounds = L.latLngBounds(L.latLng(-90,-180), L.latLng(90,180));
map.setMaxBounds(bounds);

// ================================
// BASEMAPS
// ================================
const basemapOSM = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 25,
  noWrap: true,
  bounds: bounds,
  attribution: '© OpenStreetMap contributors'
});

const basemapTopo = L.tileLayer(
  'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',
  { maxZoom: 25, attribution: 'Tiles © Esri' }
);

const basemapSatellite = L.tileLayer(
  'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
  { maxZoom: 25, attribution: 'Tiles © Esri' }
);

const basemapOpenTopo = L.tileLayer(
  'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
  { maxZoom: 17, attribution: '© OpenTopoMap (CC-BY-SA)' }
);

const basemapLight = L.tileLayer(
  'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
  { maxZoom: 25, attribution: '© CartoDB' }
);

const basemapDark = L.tileLayer(
  'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
  { maxZoom: 25, attribution: '© CartoDB' }
);

const basemapHillshade = L.tileLayer(
  'https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}',
  { maxZoom: 20, attribution: '© Esri' }
);

// Add default basemap
basemapOSM.addTo(map);

const baseMaps = {
  "OpenStreetMap": basemapOSM,
  "ESRI Topo": basemapTopo,
  "ESRI Satellite": basemapSatellite,
  "OpenTopoMap": basemapOpenTopo,
  "Light Mode": basemapLight,
  "Dark Mode": basemapDark,
  "ESRI Hillshade": basemapHillshade
};



// overlays container + layer control
const overlayLayers = {};
const layerControl = L.control.layers(baseMaps, overlayLayers, { collapsed: false }).addTo(map);

// expose globals for loader script
window.map = map;
window.overlayLayers = overlayLayers;
window.layerControl = layerControl;

// Put GeoJSON above tiles and make sure it can receive mouse events
map.createPane('geojsonPane');
map.getPane('geojsonPane').style.zIndex = 650;      // tiles are ~200
map.getPane('geojsonPane').style.pointerEvents = 'auto';
window.geojsonPane = 'geojsonPane';


// ================================
// BUFFER TOOL (UI)
// ================================
let bufferLayer = null;

const BufferControl = L.Control.extend({
  onAdd: function () {
    const div = L.DomUtil.create('div', 'leaflet-bar');
    div.style.background = 'white';
    div.style.padding = '8px';
    div.style.fontFamily = 'Arial, sans-serif';
    div.style.fontSize = '12px';
    div.style.lineHeight = '1.2';
    div.style.minWidth = '160px';

    div.innerHTML = `
      <div style="font-weight:bold; margin-bottom:6px;">Buffer</div>
      <div style="display:flex; gap:6px; align-items:center;">
        <input id="bufDist" type="number" value="10" min="0" step="1"
               style="width:70px; padding:3px;" />
        <select id="bufUnit" style="padding:3px;">
          <option value="meters" selected>m</option>
          <option value="kilometers">km</option>
          <option value="feet">ft</option>
          <option value="miles">mi</option>
        </select>
        <button id="bufBtn" style="padding:3px 6px; cursor:pointer;">Create</button>
      </div>
      <div style="margin-top:6px;">
        <button id="bufClear" style="padding:3px 6px; cursor:pointer;">Clear</button>
      </div>
    `;

    // prevent map dragging/zoom when interacting with the control
    L.DomEvent.disableClickPropagation(div);
    L.DomEvent.disableScrollPropagation(div);

    // events
    div.querySelector('#bufBtn').addEventListener('click', () => {
      if (!window.__selectedLayer) {
        alert("Select a feature first.");
        return;
      }

      const dist = Number(div.querySelector('#bufDist').value);
      const unit = div.querySelector('#bufUnit').value;

      if (!Number.isFinite(dist) || dist <= 0) {
        alert("Enter a buffer distance > 0.");
        return;
      }

      // GeoJSON from selected Leaflet layer
      const gj = window.__selectedLayer.toGeoJSON();

      // Turf buffer (works best if your GeoJSON is in EPSG:4326, which Leaflet expects)
      const buffered = turf.buffer(gj, dist, { units: unit });

      // remove old buffer
      if (bufferLayer) {
        map.removeLayer(bufferLayer);
        bufferLayer = null;
      }

      // draw buffer
      bufferLayer = L.geoJSON(buffered, {
        pane: window.geojsonPane || 'overlayPane',
        interactive: false,
        style: { weight: 2, opacity: 1, fillOpacity: 0.15 }
      }).addTo(map);

      // zoom to buffer
      try { map.fitBounds(bufferLayer.getBounds(), { padding: [20, 20] }); } catch (e) {}
    });

    div.querySelector('#bufClear').addEventListener('click', () => {
      if (bufferLayer) {
        map.removeLayer(bufferLayer);
        bufferLayer = null;
      }
    });

    return div;
  }
});

map.addControl(new BufferControl({ position: 'topright' }));


// ================================
// MEASURE TOOL (Length + Area)
// ================================
const measureGroup = L.featureGroup().addTo(map);

let measuring = null;           // "length" | "area" | null
let measurePts = [];
let tempLine = null;
let tempPoly = null;
let tempTooltip = null;

function formatLength(m) {
  if (m >= 1000) return (m / 1000).toFixed(3) + " km";
  return m.toFixed(2) + " m";
}

function formatArea(m2) {
  if (m2 >= 1e6) return (m2 / 1e6).toFixed(3) + " km²";
  if (m2 >= 1e4) return (m2 / 1e4).toFixed(3) + " ha";
  return m2.toFixed(2) + " m²";
}

function clearMeasure() {
  measureGroup.clearLayers();
  measurePts = [];
  measuring = null;
  tempLine = null;
  tempPoly = null;
  if (tempTooltip) { map.removeLayer(tempTooltip); tempTooltip = null; }
  map.getContainer().style.cursor = '';
}

function startMeasure(mode) {
  clearMeasure();
  measuring = mode;
  map.getContainer().style.cursor = 'crosshair';
  infoDiv.innerHTML = `<b>Measure</b><br>${mode === "length" ? "Length" : "Area"} mode: click points, double-click to finish.`;
}

// prevent double click zoom while measuring
map.on('dblclick', (e) => {
  if (!measuring) return;
  L.DomEvent.stop(e);
});

// update temp shapes
function updateMeasureGraphics(cursorLatLng) {
  if (!measuring || measurePts.length === 0) return;

  const latlngs = [...measurePts, cursorLatLng];

  // temp line
  if (tempLine) measureGroup.removeLayer(tempLine);
  tempLine = L.polyline(latlngs, { weight: 2, opacity: 1 }).addTo(measureGroup);

  // temp polygon (area mode)
  if (measuring === "area") {
    if (tempPoly) measureGroup.removeLayer(tempPoly);
    tempPoly = L.polygon(latlngs, { weight: 2, opacity: 1, fillOpacity: 0.15 }).addTo(measureGroup);
  }

  // tooltip text
  let text = "";
  const coords = latlngs.map(ll => [ll.lng, ll.lat]);

  if (measuring === "length") {
    const line = turf.lineString(coords);
    const km = turf.length(line, { units: "kilometers" });
    text = "Length: " + formatLength(km * 1000);
  } else if (measuring === "area" && latlngs.length >= 3) {
    const poly = turf.polygon([[...coords, coords[0]]]);
    const a = turf.area(poly);
    text = "Area: " + formatArea(a);
  } else {
    text = (measuring === "area") ? "Click 3+ points…" : "Click more points…";
  }

  if (tempTooltip) map.removeLayer(tempTooltip);
  tempTooltip = L.tooltip({ permanent: false, direction: 'top' })
    .setLatLng(cursorLatLng)
    .setContent(text)
    .addTo(map);
}

// click to add point
map.on('click', (e) => {
  if (!measuring) return;

  measurePts.push(e.latlng);

  // add a vertex marker
  L.circleMarker(e.latlng, { radius: 4, opacity: 1, fillOpacity: 1 }).addTo(measureGroup);
});

// mouse move for live preview
map.on('mousemove', (e) => {
  if (!measuring) return;
  updateMeasureGraphics(e.latlng);
});

// double click to finish measurement
map.on('dblclick', (e) => {
  if (!measuring) return;

  // finalize with current mouse position not needed; just compute from measurePts
  if (measuring === "length" && measurePts.length >= 2) {
    const coords = measurePts.map(ll => [ll.lng, ll.lat]);
    const line = turf.lineString(coords);
    const km = turf.length(line, { units: "kilometers" });
    const msg = "Length: " + formatLength(km * 1000);
    infoDiv.innerHTML = `<b>Measure result</b><br>${msg}`;
  }

  if (measuring === "area" && measurePts.length >= 3) {
    const coords = measurePts.map(ll => [ll.lng, ll.lat]);
    const poly = turf.polygon([[...coords, coords[0]]]);
    const a = turf.area(poly);
    const msg = "Area: " + formatArea(a);
    infoDiv.innerHTML = `<b>Measure result</b><br>${msg}`;
  }

  // stop measuring (keep drawn result)
  measuring = null;
  map.getContainer().style.cursor = '';
  if (tempTooltip) { map.removeLayer(tempTooltip); tempTooltip = null; }
});

const MeasureControl = L.Control.extend({
  onAdd: function () {
    const div = L.DomUtil.create('div', 'leaflet-bar');
    div.style.background = 'white';
    div.style.padding = '8px';
    div.style.fontFamily = 'Arial, sans-serif';
    div.style.fontSize = '12px';
    div.style.minWidth = '160px';

    div.innerHTML = `
      <div style="font-weight:bold; margin-bottom:6px;">Measure</div>
      <div style="display:flex; gap:6px; flex-wrap:wrap;">
        <button id="mLen" style="padding:3px 6px; cursor:pointer;">Length</button>
        <button id="mArea" style="padding:3px 6px; cursor:pointer;">Area</button>
        <button id="mClear" style="padding:3px 6px; cursor:pointer;">Clear</button>
      </div>
    `;

    L.DomEvent.disableClickPropagation(div);
    L.DomEvent.disableScrollPropagation(div);

    div.querySelector('#mLen').onclick = () => startMeasure("length");
    div.querySelector('#mArea').onclick = () => startMeasure("area");
    div.querySelector('#mClear').onclick = () => clearMeasure();

    return div;
  }
});

map.addControl(new MeasureControl({ position: 'topright' }));

// ================================
// SELECTION
// ================================
const infoDiv = document.getElementById('info');
let selected = null;

window.attachSelectableFeature = function(feature, layer) {

  if (layer.options) layer.options.interactive = true;

  layer.on('click', (e) => {
    console.log("FEATURE CLICKED ✅", feature);

    // restore previous
    if (selected) {
      try { selected.setStyle(selected._origStyle); } catch (err) {}
    }

    // store original style ONCE
    if (!layer._origStyle) {
      layer._origStyle = {
        color: layer.options.color || '#3388ff',
        weight: layer.options.weight || 3,
        opacity: layer.options.opacity ?? 1,
        fillColor: layer.options.fillColor,
        fillOpacity: layer.options.fillOpacity
      };
    }

    // highlight
    if (layer.setStyle) layer.setStyle({ color: 'yellow', weight: 6, opacity: 1 });
    if (layer.bringToFront) layer.bringToFront();
    selected = layer;
    window.__selectedLayer = layer;

    // ✅ Only show layer name
    const layerName = layer._layerName || "Unnamed layer";
    const html = `<b>Layer:</b> ${layerName}`;

    layer.bindPopup(html).openPopup();
    infoDiv.innerHTML = `<b>Selected</b><br>${html}`;

    L.DomEvent.stopPropagation(e);
  });
};
</script>

<!-- Load all GeoJSON layers -->
<script src="Layers_updating_By_Layers_json.js"></script>

</body>
</html>
